<html color-mode="user" lang="fr">
  <head>
  <base href='/fr' />
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4');
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>Conseils pour les Migrations MongoDB dans Rails</title>

<meta property="og:title" content="Conseils pour les Migrations MongoDB dans Rails"/>
<meta property="og:description" content="continuer." />
<meta property="og:image" content="https://drawohara.io/media/mick.jpg" />

  <meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"conseils-pour-les-migrations-mongodb-dans-rails"}">
    <meta property="site:path_info" content=""/conseils-pour-les-migrations-mongodb-dans-rails"">

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }
    </style>

    <script>
      document.addEventListener("turbo:load", function() {
        const progressBar = document.querySelector('.turbo-progress-bar');
        if (progressBar) {
          progressBar.remove();
        }
      });
    </script>
  </head>

  <body>
    <header>
      <a href="/accueil">@drawohara</a>
<hr>
    </header>

    <main>
      <p>Je voulais partager une méthode rapide et facile pour tester les migrations Rails lors de l'utilisation de la base de données MongoDB. La flexibilité de mongo et de ruby rend cela assez simple. Dans cet exemple, nous allons renommer un champ dans notre collection "livres" d'exemple de "isbn" à "numéro_livre". Il s'agit d'un type de migration assez courant et une fois que vous aurez compris ce cas simple, des migrations plus complexes suivront le même modèle. Tout d'abord, générons notre script de migration horodaté de base.</p>
<pre><code>rails generate migration rename_isbn_to_book_number
</code>
</pre>
<p>Ensuite, nous allons éditer le fichier généré sous <code>db/migrate</code>. Nous allons diviser notre code en plusieurs sections comme suit.</p>
<ol>
<li>Quelques constantes de classe partagées par toutes les méthodes</li>
<li>La méthode <code>self.up</code> qui effectue la migration en avant</li>
<li>Une méthode d'aide pour configurer des données d'échantillon pour tester la migration en avant</li>
<li>La méthode <code>self.down</code> qui effectue le retour en arrière</li>
<li>Une méthode d'aide pour configurer des données d'échantillon (si nécessaire) pour tester le retour en arrière</li>
</ol>
<p>Tout d'abord, définissons simplement quelques constantes que nos méthodes vont utiliser. Nous stockons le hachage des options de mise à jour mongo <code>MultiUpdate</code> pour plus de commodité puisque la plupart des opérations de mise à jour de migration souhaitent upsert false (ne créez aucun nouveau document), multi true (mettez à jour tous les documents correspondants), et sécurisé true.</p>
<p>Ensuite, nous définissons également une constante pour le nom de la collection. Pour la migration réelle, la collection est "livres", mais pour les tests, nous allons créer une nouvelle collection appelée "test_livres_migration" à mesure que nous développons notre code.</p>
<pre><code>class RenameIsbnToBookNumber &lt; Mongoid::Migration
  MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
  Collection = db.collection("livres") #Code de production final
  Collection = db.collection("test_livres_migration") #Juste pour les tests sur la console
  def up
  end

  def down
  end
end
</code>
</pre>
<p>D'accord, c'est notre modèle de base initial. L'étape suivante consiste à faire une sauvegarde de notre base de données de développement si des données s'y trouvent que nous ne voulons pas accidentellement perdre. Ensuite, nous commençons à coder une petite méthode d'aide pour remplir notre collection de test avec des documents fictifs ressemblant à ce que nous nous attendons à voir en production, mais en nous concentrant uniquement sur les champs pertinents pour la migration. Ajoutez cette méthode à votre classe de migration.</p>
<pre><code>def mock_data_for_testing_up
  3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
end

def show_collection
  Collection.find({}).each {|_| puts _}
end
</code>
</pre>
<p>Cela créera 3 documents fictifs que nous pouvons utiliser pour les tests. Nous mettons ce code dans une méthode pour qu'il soit facile de le réexécuter à mesure que nous ajustons et testons notre code de migration. Pour les migrations complexes, de nombreuses séries d'ajustements peuvent être nécessaires pour gérer tous les cas limites.</p>
<p>Nous pouvons maintenant lancer une console rails et exécuter ce code en copiant et collant les 2 constantes de classe et la méthode mock_data_for_testing_up dans la console puis en exécutant mock_data_for_testing_up</p>
<pre><code>$ bundle exec rails console
Loading development environment (Rails 3.1.1)
irb(main):001:0&gt; #Collez ce qui suit dans la console
MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
Collection = db.collection("test_livres_migration") #Juste pour les tests sur la console
def mock_data_for_testing_up
  3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
  Collection.find({}).each {|_| puts _}
end
def show_collection
  Collection.find({}).each {|_| puts _}
end
irb(main):008:0&gt; mock_data_for_testing_up
mock_data_for_testing_up
MONGODB app_development['test_livres_migration'].insert([{"isbn"=&gt;"0", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000001')}])
MONGODB app_development['test_livres_migration'].insert([{"isbn"=&gt;"1", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000002')}])
MONGODB app_development['test_livres_migration'].insert([{"isbn"=&gt;"2", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000003')}])
irb(main):009:0&gt; show_collection
MONGODB app_development['test_livres_migration'].find({})
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000001'), "isbn"=&gt;"0"}
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000002'), "isbn"=&gt;"1"}
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000003'), "isbn"=&gt;"2"}
=&gt; nil
</code>
</pre>
<p>Nous avons donc une collection de test distincte, bien comprise, prête à tester notre migration simple. Codons notre méthode <code>up</code>. Pour effectuer notre migration.</p>
<pre><code>def up
  #Nous voulons renommer le champ livre.isbn en livre.numéro_livre
  Collection.find({"isbn" =&gt; {"$exists" =&gt; 1}}).each do |livre|
    update_op = {
      "$unset" =&gt; {"isbn" =&gt; 1},
      "$set" =&gt; {"numéro_livre" =&gt; livre["isbn"]}
    }
  Collection.update({"_id" =&gt; livre["_id"]}, update_op, MultiUpdate)
end
</code>
</pre>
<p>Nous pouvons coller cela dans la console et l'exécuter pour tester notre migration. Nous pouvons vérifier les résultats avec <code>show_colletion</code>. Si nous voulons tester d'autres enregistrements pour le retour en arrière, nous pouvons créer une méthode <code>mock_data_for_testing_down</code>.</p>
<p>Cela devrait vous donner un moyen vraiment rapide d'expérimenter et de faire fonctionner votre code de migration. Mongo possède des capacités de requête et de modification avancées qui peuvent réaliser des choses incroyables, et un moyen facile de faire quelques essais et erreurs est pratique. Si vous faites un gâchis de vos données de test, vous pouvez utiliser <code>Collection.drop</code> pour obtenir une ardoise propre. Voici le code de migration final pour référence. <strong>N'oubliez pas</strong> de supprimer la constante de collection de test et de supprimer la collection de test de votre base de données lorsque vous êtes prêt à commencer à exécuter votre code pour de vrai avec <code>rake db:migrate</code>.</p>
<pre><code>class RenameIsbnToBookNumber &lt; Mongoid::Migration
  MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
  Collection = db.collection("livres") #Code de production final

  def up
    #Nous voulons renommer le champ livre.isbn en livre.numéro_livre
    Collection.find({"isbn" =&gt; {"$exists" =&gt; 1}}).each do |livre|
      update_op = {
        "$unset" =&gt; {"isbn" =&gt; 1},
        "$set" =&gt; {"numéro_livre" =&gt; livre["isbn"]}
      }
      Collection.update({"_id" =&gt; livre["_id"]}, update_op, MultiUpdate)
    end
  end

  def down
    #Nous voulons renommer le champ livre.numéro_livre en livre.isbn
    Collection.find({"numéro_livre" =&gt; {"$exists" =&gt; 1}}).each do |livre|
      update_op = {
        "$unset" =&gt; {"numéro_livre" =&gt; 1},
        "$set" =&gt; {"isbn" =&gt; livre["numéro_livre"]}
      }
      Collection.update({"_id" =&gt; livre["_id"]}, update_op, MultiUpdate)
    end
  end

  #Ces méthodes ne sont pas appelées par la migration. Juste pour les tests manuels
  #par copier/coller dans la console
  #Pour tester (par copier/coller d'ici à la console)
  #1. Définissez la constante MultiUpdate. Ajustez "Collection" pour qu'elle soit une collection de test
  #2. Copiez/collez les 2 méthodes ci-dessous
  #2. Exécutez mock_data_for_testing_up
  #3. Exécutez le corps de self.up
  #3b. Optionnellement, exécutez à nouveau le corps de self.up pour vous assurer qu'il est idempotent
  def mock_data_for_testing_up
    3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
  end

  def show_collection
    Collection.find({}).each {|_| puts _}
  end
end
</code>
</pre>
    </main>

    <footer>
      <hr>
<a href="/aller-à" name="goto">&mdash;&gt; aller à</a>
<blockquote>
<ul>
  <li>
    <a href="/à-propos">à propos<a>
  </li>
  <li>
    <a href="mailto:je-déteste-ça@drawohara.io?subject=/conseils-pour-les-migrations-mongodb-dans-rails">je-déteste-ça<a>
  </li>
  <li>
    <a href="mailto:j'aime-ça@drawohara.io?subject=/conseils-pour-les-migrations-mongodb-dans-rails">j'aime-ça<a>
  </li>
  <li>
    <a href="/contact">contact<a>
  </li>
</ul>
</blockquote>
<a href="/">&lt;&mdash; ejecter</a>
    </footer>
  </body>
</html>