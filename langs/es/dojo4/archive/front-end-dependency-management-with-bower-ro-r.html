<html color-mode="user" lang="es">
  <head>
  <base href='/es' />
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4');
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>Gestión de Dependencias del Front-End con Bower &amp; RoR</title>

<meta property="og:title" content="Gestión de Dependencias del Front-End con Bower &amp; RoR"/>
<meta property="og:description" content="sigue adelante." />
<meta property="og:image" content="https://drawohara.io/media/mick.jpg" />

  <meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"front-end-dependency-management-with-bower-ro-r"}">
    <meta property="site:path_info" content=""/front-end-dependency-management-with-bower-ro-r"">

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }
    </style>

    <script>
      document.addEventListener("turbo:load", function() {
        const progressBar = document.querySelector('.turbo-progress-bar');
        if (progressBar) {
          progressBar.remove();
        }
      });
    </script>
  </head>

  <body>
    <header>
      <a href="/home">@drawohara</a>
<hr>
    </header>

    <main>
      <div class="ro markdown">

<p>La gestión de dependencias puede ser complicada. Cuando me uní a dojo4 hace unas semanas, fue genial clonar un repositorio de un proyecto de ruby on rails, poder hacer un <code>bundle install</code> y luego ejecutar la aplicación con <code>rails s</code>. Para aquellos que no están familiarizados con la gestión de dependencias de ruby on rails, las gemas necesarias para ejecutar la aplicación se listan en un archivo llamado <code>Gemfile</code>. La aplicación bundle lee este gemfile y descarga e instala cualquier gema que aún no esté en tu computadora. No solo esto facilita que la aplicación se ejecute correctamente de manera rápida y sin mucho esfuerzo de configuración, sino que también facilita la actualización de esas gemas dependientes cuando se lanza una nueva versión. Ejecutar <code>bundle update</code> o actualizar el gemfile y ejecutar <code>bundle install</code> nuevamente hace que este sea un proceso fácil que garantiza que todos los demás usuarios de la aplicación también usarán la nueva versión (siempre que compartamos los cambios a través del control de fuente). Este es un flujo de trabajo excelente para el lado del servidor, pero ¿qué hay del lado del cliente?</p>

<p>A medida que las aplicaciones del cliente se vuelven más complicadas, a menudo necesitamos la ayuda de bibliotecas y frameworks en el cliente también. En dojo4, actualmente descargamos los archivos que necesitamos y los colocamos manualmente en el control de fuente y los confirmamos. Los archivos están bajo control de fuente, por lo que al menos todos obtendrán esos archivos y podemos revertir una actualización de versión, pero es un poco desordenado. Para actualizar los archivos de la biblioteca, debemos repetir el proceso manual. En el lado del servidor, también es muy agradable que las tareas de gestión de dependencias estén menos estrechamente acopladas con el código de la aplicación para que actualizar y revertir versiones sea más fácil. Desafortunadamente, no había una buena manera de gestionar las dependencias para el front-end. Hasta hace poco.</p>

<p>En septiembre del año pasado, Twitter lanzó <a href="http://bower.io">Bower</a>, que ofrece "una solución genérica y no opinada al problema de la gestión de paquetes del front-end". Bower proporciona las mismas capacidades para la aplicación del front-end que bundle para el back-end: una lista central de dependencias en un archivo, comandos fáciles de instalar y actualizar, y alguna separación del código de la aplicación y los commits. Mientras investigaba cómo podríamos aprovechar esto en nuestra aplicación estándar de ruby on rails, los creadores de Bower me remitieron a la gema <a href="https://github.com/42dev/bower-rails/">bower-rails</a>, que integra bower en la estructura de directorios de ruby on rails y agrega algunos comandos <code>rake</code> para ejecutar comandos de bower. Ahora, en lugar de confirmar manualmente los archivos de la biblioteca en el repositorio de la aplicación, un desarrollador puede hacer <code>rake bower:install [nombre del paquete]</code> y se instalará la última versión de ese paquete en el pipeline de activos y se agregará a la lista de paquetes requeridos. Un nuevo desarrollador puede luego descargar el código de la aplicación y, después de ejecutar <code>bundle install</code>, puede ejecutar <code>rake bower:install</code> y todas las dependencias del front-end se instalarán en el directorio adecuado en el pipeline de activos de ruby on rails para su uso inmediato.</p>

<p>Personalmente, me gusta mucho este enfoque y espero que podamos convertir las bibliotecas del front-end que se agregan manualmente al enfoque de bower. Todavía estamos discutiendo internamente los beneficios y desventajas y tomaremos una decisión pronto. ¿Qué opinas? ¿Cómo manejas las dependencias del front-end en un equipo distribuido?</p>

</div>
    </main>

    <footer>
      <hr>
<a href="/ir" name="ir">&mdash;&gt; ir</a>
<blockquote>
<ul>
  <li>
    <a href="/sobre">sobre<a>
  </li>
  <li>
    <a href="mailto:odio-esto@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">odio-esto<a>
  </li>
  <li>
    <a href="mailto:amo-esto@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">amo-esto<a>
  </li>
  <li>
    <a href="/contacto">contacto<a>
  </li>
</ul>
</blockquote>
<a href="/">&lt;&mdash; salir</a>
    </footer>
  </body>
</html>