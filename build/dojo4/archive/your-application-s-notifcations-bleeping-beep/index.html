<html color-mode="user" lang="en">
  <head>
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4', {'debug_mode':true});
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- langs -->
  <!--
    https://developers.google.com/search/docs/specialty/international/localized-versions#html
  -->
   <link rel="alternate" hreflang="en" href="/" />
   <link rel="alternate" hreflang="uk" href="https://drawohara.io/langs/uk" />
   <link rel="alternate" hreflang="sv" href="https://drawohara.io/langs/sv" />
   <link rel="alternate" hreflang="fr" href="https://drawohara.io/langs/fr" />
   <link rel="alternate" hreflang="es" href="https://drawohara.io/langs/es" />
   <link rel="alternate" hreflang="it" href="https://drawohara.io/langs/it" />

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>Your Application&#39;s Notifcations Bleeping BEEP</title>

<meta property="og:title" content="Your Application&#39;s Notifcations Bleeping BEEP"/>
<meta property="og:description" content="move along." />
<meta property="og:image" content="https://drawohara.io/media/tauntaun.jpg" />




  <meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"your-application-s-notifcations-bleeping-beep"}">
    <meta property="site:path_info" content=""/your-application-s-notifcations-bleeping-beep"">

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      @media (min-width: 768px) {
        body {
          max-width: 66%;
          margin: auto;
        }
      }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }

      /* markdown shit */
      .highlighter-rouge { background: white !important; }
      .code { background: white !important; }
    </style>

    <script defer>
    /* anti turbo */
    document.addEventListener("turbo:load", function() {
      const progressBar = document.querySelector('.turbo-progress-bar');
      if (progressBar) {
        progressBar.remove();
      }
    });
    </script>

    <style>
      .youtube-video-container {
        position: relative; /* Establishes a positioning context for the iframe */
        width: 100%;      /* Takes the full width of its parent */
        overflow: hidden;
        padding-top: 56.25%; /* 16:9 Aspect Ratio (9 / 16 * 100) */
        /* Adjust this percentage if your videos have a different aspect ratio */
        height: 0; /* Collapse the container's original height */
      }

      .youtube-video-container iframe {
        position: absolute; /* Positions the iframe relative to the container */
        top: 0;
        left: 0;
        width: 100%;      /* Fills the container horizontally */
        height: 100%;     /* Fills the container vertically */
        border: 0;        /* Optional: removes default border */
      }
    </style>
    <script>
      // Define the function that finds and wraps YouTube iframes
      function wrapYouTubeIframes() {
        const youtubeIframes = document.querySelectorAll('iframe[src*="youtube.com"]');
        const containerClassName = 'youtube-video-container';

        if (youtubeIframes.length === 0) {
            // console.log('No YouTube iframes found to wrap.'); // Optional debug log
            return; // Exit if no iframes found
        }
        // console.log(`Found ${youtubeIframes.length} YouTube iframes to process.`); // Optional debug log

        youtubeIframes.forEach(iframe => {
          // Check if already wrapped
          if (!iframe.parentNode || !iframe.parentNode.classList.contains(containerClassName)) {
            // console.log('Wrapping iframe:', iframe.src); // Optional debug log

            // Remove fixed width/height attributes from the iframe itself
            iframe.removeAttribute('width');
            iframe.removeAttribute('height');

            // Create the wrapper div element
            const wrapper = document.createElement('div');
            wrapper.classList.add(containerClassName);

            // Insert the wrapper div right before the iframe in the DOM
            // Need to check if iframe has a parent before inserting relative to it
            if (iframe.parentNode) {
                iframe.parentNode.insertBefore(wrapper, iframe);
                // Move the iframe inside the newly created wrapper div
                wrapper.appendChild(iframe);
            } else {
                // console.warn("Orphan iframe found, cannot wrap:", iframe); // Should ideally not happen in valid HTML
            }

          } else {
              // console.log('Iframe already wrapped:', iframe.src); // Optional debug log
              // Even if wrapped, ensure attributes are removed
              iframe.removeAttribute('width');
              iframe.removeAttribute('height');
          }
        });
      }

      // --- Execution Hooks ---

      // Option 1: Run on initial load AND after Turbo navigations (Recommended)
      // Use 'turbo:load' which fires both after the initial page load and subsequent Turbo visits.
      document.addEventListener('turbo:load', function() {
        // console.log('turbo:load event fired - wrapping YouTube iframes'); // Optional debug log
        wrapYouTubeIframes();
      });

      // Option 2: Explicitly run on initial load (if not using defer/module or for extra safety)
      // If your script might run before Turbo is fully ready or if Turbo might be absent,
      // you might also call it directly or use DOMContentLoaded as a fallback/primary trigger.
      // However, 'turbo:load' *should* cover the initial load too. If you experience issues
      // where initial load isn't handled, uncomment the line below.
      // document.addEventListener('DOMContentLoaded', wrapYouTubeIframes);


      // --- Handling Dynamically Added Iframes (Advanced) ---

      // The above listeners handle iframes present during the 'turbo:load' event.
      // If iframes are added *later* via JavaScript, Turbo Streams, Stimulus actions, etc.,
      // the 'turbo:load' event won't re-fire for those specific additions.
      // For those cases, you have a few options:

      // A) Manually call `wrapYouTubeIframes()` after you know new content containing iframes has been added.

      // B) Use a MutationObserver to automatically detect when *any* nodes are added to the page
      //    and check if they contain iframes that need wrapping. This is more robust but complex.
      /*
      const observerCallback = (mutationsList, observer) => {
        let needsWrap = false;
        for (const mutation of mutationsList) {
          if (mutation.type === 'childList') {
            for (const node of mutation.addedNodes) {
              if (node.nodeType === Node.ELEMENT_NODE) {
                // Check if the added node IS an iframe or CONTAINS iframes
                if (node.matches('iframe[src*="youtube.com"]') || node.querySelector('iframe[src*="youtube.com"]')) {
                  needsWrap = true;
                  break; // Found one, no need to check further in this mutation record
                }
              }
            }
          }
          if (needsWrap) break; // Found one, no need to check further mutations
        }
        if (needsWrap) {
          // console.log('MutationObserver detected potential new iframes, re-running wrap.'); // Optional debug log
          wrapYouTubeIframes(); // Re-run the wrapping function
        }
      };

      const observer = new MutationObserver(observerCallback);

      // Start observing the document body for additions/removals in the subtree
      // Make sure this runs *after* the body exists
      if (document.body) {
          observer.observe(document.body, { childList: true, subtree: true });
      } else {
          document.addEventListener('DOMContentLoaded', () => {
              observer.observe(document.body, { childList: true, subtree: true });
          });
      }
      */
    </script>
  </head>

  <body>
    <header>
      <a href="/">@drawohara</a>
&nbsp;
<small>
  <a href="mailto:i-love-this@drawohara.io?subject=/your-application-s-notifcations-bleeping-beep">‚ù§Ô∏è </a>
    ||
  <a href="mailto:i-hate-that@drawohara.io?subject=/your-application-s-notifcations-bleeping-beep">üñ§</a>
</small>
<hr>
    </header>

    <main>
      <em>published on: 2014-02-20</em>
<br>
<br>
<div class="ro markdown">
  <p>‚ÄúAnything with a sound should have a volume. They should teach this to mechanical engineers.‚Äù ‚Äì Gary Snyder</p>

<p>Nothing annoys me more than things which beep or make sounds to get attention. From dishwashers, clocks, watches, smoke detectors, cars, to phones. All of it!</p>

<p>I have none of the following in my house:</p>

<ul>
  <li>TV</li>
  <li>radio</li>
  <li>alarm clock</li>
  <li>doorbell</li>
</ul>

<p>Everything electronic on my 90 suburban is busted (I like it that way)
My phone‚Äôs ring tone is 5 seconds of silence. I do have a ‚ÄòPeople Under the Stairs‚Äô sample that plays when my wife calls though - a <a href="http://s3.amazonaws.com/drawohara.com.mp3/18_acid_raindrops.mp3">really pleasant flute clip</a>.</p>
<ul>
  <li>The sounds on my computer are all turned off (except one or two bloody ones I cannot find ‚Äì grrrr!)</li>
  <li>I could never use the beeper on my watches or heart-rate monitors when I used them</li>
  <li>Our house doesn‚Äôt even have a fire alarm (I know, I know‚Ä¶)</li>
</ul>

<p>The wife likes to use the timer on the stove for - timing things on the stove - which probably makes sense to normal people but, for me, the teeny beeeeeeep when the time is up is like a spear through my head every time it goes off.</p>

<p>This is really strange considering that, if I could, I‚Äôd listen to music 24x7 - even while sleeping.</p>

<p>I recall my dad tearing out the ‚Äòopen door dinger‚Äô on a new truck we‚Äôd just bought <em>in the dealer‚Äôs lot</em> before he‚Äôd get in it to drive it home so - perhaps it‚Äôs a genetic disposition.
In any case I am sure I am not the only one who thinks the ‚Äòbeep‚Äô is the worst human interface design feature <em>ever</em>?</p>

<p>Some of you are probably with me so far but - here is the thing - modern application design is full of crappy sounding beeps!</p>

<ul>
  <li>dashboard notifications</li>
  <li>growl</li>
  <li>little counters on web tabs</li>
  <li>holy effing iphone notifications</li>
  <li>facebook messaging (man how <em>do</em> I turn that one off?)</li>
  <li>push notifications</li>
  <li>a <em>billion</em> emails reminding us to be reminded to come back and check out what the beep is going on</li>
</ul>

<p>Everywhere there are little numbers of beeps stacking up in our user interfaces that, somehow, designers and developers consider less offensive than all of those things <em>actually</em> beeping every two seconds in people‚Äôs ears.</p>

<p>I wonder how many engineers and designers have examined the notification systems of early Unices? (And yes, that <em>is</em> plural for Unix)</p>

<p>Back in the day, simple Unix programs had three choices for notifications: audible bell, visual bell, or no bell.  True story, check it out</p>

<p><a href="http://www.gnu.org/software/bash/manual/bashref.html#index-bell_002dstyle" target="_blank">http://www.gnu.org/software/bash/manual/bashref.html#index-bell_002dstyle</a></p>

<p>So riddle me this ux girl: why is that?</p>

<p>As it turns out, the audible bell can be a really useful tool when someone is doing many important things.  For instance, when logging in to several remote systems, doing some work, not looking at something, and needing to know when something you aren‚Äôt looking at needs attention.  It‚Äôs a known fact that only people with a nutritional deficiency which destroys the ability to think rationally, prefer this type of notification and, for this reason, the designers of Unix included it as an options for global notification.</p>

<p>Another option, the visual bell, just makes the application you‚Äôre in flash a teeny bit when it wants your attention, sort of like someone flicking the lights.  It‚Äôs mildly irritating too but, for most developers, preferable to a loud beep.</p>

<p>No bell, my favorite.  I‚Äôd leave out an explanation of this one except that I know some people who prefer beeps are reading this article and, for them, it bears explanation.  With no bell, an application which needs to notify someone</p>

<ul>
  <li>makes no sound</li>
  <li>is silent</li>
  <li>basically nothing happens.  it‚Äôs a mute button!</li>
</ul>

<p>Now, these three simple options might not seem that powerful but, like most things in Unix, there is power in orthogonality that mere hackers cannot deduce:</p>

<ul>
  <li>
    <p>Inheritance: The setting for which style of notification you want is a global setting, but can easily be set per application when launching it.  That is to say all applications inherit the default, user preferred, mechanism and keep it for their lifetime, and applications that spawn other applications (think browser tabs) inherit the setting of their parent.</p>
  </li>
  <li>
    <p>Global: There is one style, audible, which doesn‚Äôt require <em>seeing</em> a particular application and which there acts globally across applications - simply letting you know that ‚Äòsomething‚Äô needs attention.  This is useful if you need to put a bunch of things in the background (minimize them) or flat out can‚Äôt see (aka. are blind).  It‚Äôs also useful for the aforementioned crazy people who just like it.</p>
  </li>
  <li>
    <p>Individual: There is one style, visual, which lets you quietly notice notifications from the particular application you are actively paying attention too and yet easily ignore all the others which aren‚Äôt actively on your screen.  The way this is implemented is via a small ‚Äòflash‚Äô of brightness in the current application. This style is also useful if you can‚Äôt hear.</p>
  </li>
</ul>

<p>With these three orthogonal concepts users have, for decades, been able to finely tune how notifications were received and by which applications in quite complicated constellations.</p>

<p>Now, we all know the modern computer user needs a notification system with far more complex invariants, as you can see from my desktop:</p>

<p><img src='/ro/dojo4/your-application-s-notifcations-bleeping-beep/assets/desktop.png' alt="desktop" /></p>

<p>Okay, my desktop is a bad example ;-)</p>

<p>By the way, if the idea of defining orthogonal invariants in order to design a powerful tool is new to you - do not pass GO - proceed immediately to reading about contextual vs composable design.  Trust me though, you practice contextual design and, with notifications, that‚Äôs the bloody the problem!</p>

<p>Refs:</p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Contextual_design" target="_blank">http://en.wikipedia.org/wiki/Contextual_design</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Unix_philosophy" target="_blank">http://en.wikipedia.org/wiki/Unix_philosophy</a></li>
</ul>

<p>Read those?  Good.  Still think user-centered design is a panacea?  Or that composable is the shiznit?</p>

<p>Pop-quiz then: WHO IS THE MOST POWERFUL WIZZARD - your app or the internet?</p>

<p>‚Ä¶</p>

<p>Of course the answer is neither.  The internet wouldn‚Äôt be useful to people without <em>applications</em> to use it and no user-centered design process would have built the internet.  Translation: some things require a composable and modular design, like the internet and pan-application notifications, while others, like you favorite text editor require an user-centered one.</p>

<p>And here we come to the crux of the issue: a non-want-to-slam-your-wee-wee-in-a-car-door approach to notifications <em>cannot be solved or implemented at the application layer</em>, it has to be solved at a global level for any user that ever uses more than one simultaneous application (aka - all of them).</p>

<p>I hear the mac people frothing, but they know everyone isn‚Äôt on mac.  Besides, the unified notification systems on iOS and desktops are going to go the way of the dodo anyhow because only 1 out of a hundred applications bother to integrate with them and the rest re-invent the wheel.</p>

<p>Windows people - check an iPhone to imagine what unified notifications might look like.</p>

<p>Linux people - ‚Ä¶ yes, you understand these things, i‚Äôll shut up now.</p>

<p>So - what‚Äôs the answer?</p>

<p>Email.</p>

<p>(/me waits for laughs from the crowd to die down‚Ä¶)</p>

<p>No really.  Check this out:</p>

<ul>
  <li>email is ultra reliable</li>
  <li>email is ultra cheap</li>
  <li>email is synced to all a user‚Äôs devices like freaky magic, even when they are offline!</li>
  <li>email is √ºber easy to integrate with in any language</li>
</ul>

<p>Now, I‚Äôm not talking about ordinary email, I‚Äôm talking about simple machine parseable emails with human readable messaging in the body and structured data supplied in attachments.  Emails like this could easily be managed by a centralized program on your device that could collate and distribute them according to a ruleset: think of email filters with some special rules to alert you in various user defined ways.  Your email client already does 95% of this, with the exception of managing any structured data or performing custom user defined actions beeping at you or having Siri read you a message that you just got followed on Twitter.</p>

<p>With this approach you‚Äôd gain:</p>

<ul>
  <li>unification</li>
  <li>simplicity</li>
  <li>archival</li>
  <li>search</li>
  <li>customization</li>
  <li>and much more</li>
</ul>

<p>So why not start doing this now?  It‚Äôs crazy right?</p>

<p>Crazy, except that Google is already doing it.</p>

<p>Seen this?</p>

<p><img src='/ro/dojo4/your-application-s-notifcations-bleeping-beep/assets/gmail.png' alt="gmail.png" /></p>

<p>There‚Äôs Google in my inbox, auto-partitioning my email into ‚ÄòPrimary‚Äô, ‚ÄòSocial‚Äô, and ‚ÄòPromotions‚Äô.  In one fell swoop they just made more headway into the ‚Äòtoo many notifications too many places‚Äô problem than all the developers working on their own unique systems have combined. And I don‚Äôt have to manage a damn thing that I‚Äôm not already doing.</p>

<p>I think now is the time for developers and designs to start realizing their homespun notification systems are a waste of energy, annoying, and broken by design.  Now is the time to start taking about a composable, modular, system that is easy to integrate with, think about, and for users to interact with.</p>

<p>In the mean time we can at least do no harm: do not invent a notification system for your application, start leveraging email for notifications now and embrace the power that ubiquity and constraints combine to produce.</p>

<p>BEEEEEEEP ‚Äì this rant is over.</p>

</div>
    </main>

    <footer>
      <hr>

<a href="/goto" name="goto">&mdash;&gt; goto</a>

<blockquote>
  

  sometimes i am two people. johnny is the nice one. cash causes all the trouble.
 <br> <br> &nbsp;&nbsp;&mdash; <a href="https://en.wikipedia.org/wiki/Johnny_Cash" target="_blank">johnny cash</a>
</blockquote>

<a href="/">&lt;&mdash; eject</a>
    </footer>
  </body>
</html>