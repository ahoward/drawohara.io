<html color-mode="user" lang="es">
  <head>
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4');
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- langs -->
  <!--
    https://developers.google.com/search/docs/specialty/international/localized-versions#html
  -->
   <link rel="alternate" hreflang="en" href="/" />
   <link rel="alternate" hreflang="uk" href="https://drawohara.io/langs/uk" />
   <link rel="alternate" hreflang="sv" href="https://drawohara.io/langs/sv" />
   <link rel="alternate" hreflang="fr" href="https://drawohara.io/langs/fr" />
   <link rel="alternate" hreflang="es" href="https://drawohara.io/langs/es" />
   <link rel="alternate" hreflang="it" href="https://drawohara.io/langs/it" />

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>no hay nada que ver aqu铆.</title>

<meta property="og:title" content="no hay nada que ver aqu铆."/>
<meta property="og:description" content="sigue adelante." />
<meta property="og:image" content="https://drawohara.io/media/mick.jpg" />

<meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"tips-for-mongodb-migrations-in-rails"}">
    <meta property="site:path_info" content=""/tips-for-mongodb-migrations-in-rails"">

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }
    </style>

    <script>
      document.addEventListener("turbo:load", function() {
        const progressBar = document.querySelector('.turbo-progress-bar');
        if (progressBar) { progressBar.remove(); }
      });
    </script>
    <base href='/langs/es' />
  </head>

  <body>
    <header>
      <a href="/home">@drawohara</a> &mdash;
<a href="mailto:i-love-this@drawohara.io?subject=/tips-for-mongodb-migrations-in-rails">隆Me encanta esto!</a>
<small>
  <small>
    <small>
      <span title='b茅belo'>&lt;&lt; haga clic aqu铆   </a>
    </small>
  </small>
</small>
<hr>
<strong>/consejos-para-migraciones-de-mongodb-en-rails</strong>
    </header>

    <main>
      <em>publicado el: 2011-12-27</em>
<br>
<br>
<p>Quise compartir un m茅todo r谩pido y f谩cil para probar las migraciones de Rails cuando se utiliza la base de datos MongoDB. La flexibilidad de mongo y ruby hace que esto sea bastante sencillo. En este ejemplo, estaremos renombrando un campo en nuestra colecci贸n de ejemplo "libros" de "isbn" a "n煤mero_de_libro". Este es un tipo de migraci贸n bastante com煤n y una vez que comprendas este caso sencillo, las migraciones m谩s complejas siguen el mismo patr贸n. Primero, generemos nuestro script de plantilla de migraci贸n con marca de tiempo.</p>
<pre><code>rails generate migration rename_isbn_to_book_number
</code>
</pre>
<p>Luego editaremos el archivo que se gener贸 debajo de <code>db/migrate</code>. Dividiremos nuestro c贸digo en varias secciones de la siguiente manera.</p>
<ol>
<li>Algunas constantes de clase compartidas por todos los m茅todos</li>
<li>El m茅todo <code>self.up</code> que realiza la migraci贸n hacia adelante</li>
<li>Un m茅todo auxiliar para configurar algunos datos de ejemplo para probar la migraci贸n hacia adelante</li>
<li>El m茅todo <code>self.down</code> que realiza la reversi贸n</li>
<li>Un m茅todo auxiliar para configurar algunos datos de ejemplo (si es necesario) para probar la reversi贸n</li>
</ol>
<p>Primero, simplemente definimos algunas constantes que utilizar谩n nuestros m茅todos. Almacenamos el hash de opciones de actualizaci贸n de mongo <code>MultiUpdate</code> por conveniencia, ya que la mayor铆a de las operaciones de actualizaci贸n de migraci贸n desean upsert false (no crear ning煤n documento nuevo), multi true (actualizar todos los documentos coincidentes) y safe true.</p>
<p>Luego tambi茅n definimos una constante para el nombre de la colecci贸n. Para la migraci贸n real, la colecci贸n es "libros", pero para las pruebas, crearemos una nueva colecci贸n llamada "test_books_migration" a medida que desarrollamos nuestro c贸digo.</p>
<pre><code>class RenameIsbnToBookNumber &lt; Mongoid::Migration
  MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
  Collection = db.collection("books") #C贸digo de producci贸n final
  Collection = db.collection("test_books_migration") #Solo para pruebas en la consola
  def up
  end

  def down
  end
end
</code>
</pre>
<p>Bien, ese es nuestro plantilla inicial. El siguiente paso es hacer una copia de seguridad de nuestra base de datos de desarrollo si hay alg煤n dato all铆 que no queramos arruinar accidentalmente. Luego comenzamos a codificar un peque帽o m茅todo auxiliar para poblar nuestra colecci贸n de prueba con documentos falsos que se asemejan a lo que esperamos ver en producci贸n, pero centr谩ndonos solo en los campos relevantes para la migraci贸n. Agregue este m茅todo a su clase de migraci贸n.</p>
<pre><code>def mock_data_for_testing_up
  3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
end

def show_collection
  Collection.find({}).each {|_| puts _}
end
</code>
</pre>
<p>Esto crear谩 3 documentos ficticios que podemos usar para las pruebas. Estamos colocando este c贸digo en un m茅todo para que sea f谩cil de volver a ejecutar a medida que ajustamos y probamos nuestro c贸digo de migraci贸n. Para migraciones complejas, pueden ser necesarias muchas rondas de ajustes para abordar todos los casos l铆mite.</p>
<p>Ahora podemos iniciar una consola de rails y ejecutar este c贸digo copiando y pegando las 2 constantes de clase y el m茅todo mock_data_for_testing_up en la consola y luego ejecutando mock_data_for_testing_up</p>
<pre><code>$ bundle exec rails console
Cargando entorno de desarrollo (Rails 3.1.1)
irb(main):001:0&gt; #Pegue lo siguiente en la consola
MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
Collection = db.collection("test_books_migration") #Solo para pruebas en la consola
def mock_data_for_testing_up
  3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
  Collection.find({}).each {|_| puts _}
end
def show_collection
  Collection.find({}).each {|_| puts _}
end
irb(main):008:0&gt; mock_data_for_testing_up
mock_data_for_testing_up
MONGODB app_development['test_books_migration'].insert([{"isbn"=&gt;"0", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000001')}])
MONGODB app_development['test_books_migration'].insert([{"isbn"=&gt;"1", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000002')}])
MONGODB app_development['test_books_migration'].insert([{"isbn"=&gt;"2", :_id=&gt;BSON::ObjectId('4ef5f43b2a4397a5d7000003')}])
irb(main):009:0&gt; show_collection
MONGODB app_development['test_books_migration'].find({})
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000001'), "isbn"=&gt;"0"}
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000002'), "isbn"=&gt;"1"}
{"_id"=&gt;BSON::ObjectId('4ef5f3812a4397a5bd000003'), "isbn"=&gt;"2"}
=&gt; nil
</code>
</pre>
<p>Entonces ahora tenemos una colecci贸n de prueba separada, bien comprendida, lista para probar nuestra migraci贸n simple. Vamos a codificar nuestro m茅todo <code>up</code>. Para hacer nuestra migraci贸n.</p>
<pre><code>def up
  #Queremos renombrar el campo libro.isbn a libro.n煤mero_de_libro
  Collection.find({"isbn" =&gt; {"$exists" =&gt; 1}}).each do |book|
    update_op = {
      "$unset" =&gt; {"isbn" =&gt; 1},
      "$set" =&gt; {"book_number" =&gt; book["isbn"]}
    }
  Collection.update({"_id" =&gt; book["_id"]}, update_op, MultiUpdate)
end
</code>
</pre>
<p>Podemos pegar eso en la consola y ejecutarlo para probar nuestra migraci贸n. Podemos verificar los resultados con <code>show_colletion</code>. Si queremos probar otros registros para la reversi贸n, podemos crear un m茅todo <code>mock_data_for_testing_down</code>.</p>
<p>Esto deber铆a darte una manera realmente r谩pida de experimentar y hacer que tu c贸digo de migraci贸n funcione. Mongo tiene algunas capacidades avanzadas de consulta y modificaci贸n que pueden hacer cosas asombrosas, y una forma f谩cil de hacer algunas pruebas de ensayo y error es 煤til. Si haces un desastre con tus datos de prueba, puedes usar <code>Collection.drop</code> para obtener una pizarra limpia. Aqu铆 est谩 el c贸digo de migraci贸n final para referencia. <strong>No olvides</strong> eliminar la constante de la colecci贸n de prueba y eliminar la colecci贸n de prueba de tu base de datos cuando est茅s listo para comenzar a ejecutar tu c贸digo en serio con <code>rake db:migrate</code>.</p>
<pre><code>class RenameIsbnToBookNumber &lt; Mongoid::Migration
  MultiUpdate = {:upsert =&gt; false, :multi =&gt; true, :safe=&gt;true}
  Collection = db.collection("books") #C贸digo de producci贸n final

  def up
    #Queremos renombrar el campo libro.isbn a libro.n煤mero_de_libro
    Collection.find({"isbn" =&gt; {"$exists" =&gt; 1}}).each do |book|
      update_op = {
        "$unset" =&gt; {"isbn" =&gt; 1},
        "$set" =&gt; {"book_number" =&gt; book["isbn"]}
      }
      Collection.update({"_id" =&gt; book["_id"]}, update_op, MultiUpdate)
    end
  end

  def down
    #Queremos renombrar el campo libro.n煤mero_de_libro a libro.isbn
    Collection.find({"book_number" =&gt; {"$exists" =&gt; 1}}).each do |book|
      update_op = {
        "$unset" =&gt; {"book_number" =&gt; 1},
        "$set" =&gt; {"isbn" =&gt; book["book_number"]}
      }
      Collection.update({"_id" =&gt; book["_id"]}, update_op, MultiUpdate)
    end
  end

  #Estos m茅todos no son llamados por la migraci贸n. Solo para pruebas manuales
  #por copiar/pegar en la consola
  #Para probar (copiando/pegando desde aqu铆 a la consola)
  #1. Establezca la constante MultiUpdate. Ajuste "Collection" para que sea una colecci贸n de prueba
  #2. Copie/pegue los 2 m茅todos a continuaci贸n
  #2. Ejecute mock_data_for_testing_up
  #3. Ejecute el cuerpo de self.up
  #3b. Opcionalmente, ejecute el cuerpo de self.up nuevamente para asegurarse de que sea idempotente
  def mock_data_for_testing_up
    3.times {|number| Collection.insert({"isbn" =&gt; "#{number}"})}
  end

  def show_collection
    Collection.find({}).each {|_| puts _}
  end
end
</code>
</pre>
    </main>

    <footer>
      <hr>
<a href="/goto" name="goto">&mdash;&gt; ir a</a>
<blockquote>
<ul>
  <li>
    <a href="mailto:i-hate-this@drawohara.io?subject=/tips-for-mongodb-migrations-in-rails">, yo  ^隆esto!<a>
  </li>
  <li>
    <a href="/now">/ahora<a>
  </li>
  <li>
    <a href="/about">/sobre<a>
  </li>
  <li>
    <a href="/contact">/contacto<a>
  </li>
</ul>
</blockquote>
<a href="/">&lt;&mdash; expulsar</a>
    </footer>
  </body>
</html>