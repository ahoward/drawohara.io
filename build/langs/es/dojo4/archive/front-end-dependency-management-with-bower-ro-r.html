<html color-mode="user" lang="es">
  <head>
  <base href='/langs/es' />
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4');
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- langs -->
  <!--
    https://developers.google.com/search/docs/specialty/international/localized-versions#html
  -->
   <link rel="alternate" hreflang="en" href="/" />
   <link rel="alternate" hreflang="uk" href="https://drawohara.io/langs/uk" />
   <link rel="alternate" hreflang="sv" href="https://drawohara.io/langs/sv" />
   <link rel="alternate" hreflang="fr" href="https://drawohara.io/langs/fr" />
   <link rel="alternate" hreflang="es" href="https://drawohara.io/langs/es" />
   <link rel="alternate" hreflang="it" href="https://drawohara.io/langs/it" />

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>no hay nada que ver aqu铆.</title>

<meta property="og:title" content="no hay nada que ver aqu铆."/>
<meta property="og:description" content="siga adelante." />
<meta property="og:image" content="https://drawohara.io/media/mick.jpg" />




  <meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"front-end-dependency-management-with-bower-ro-r"}">
    <meta property="site:path_info" content=""/front-end-dependency-management-with-bower-ro-r"">

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }
    </style>

    <script>
      document.addEventListener("turbo:load", function() {
        const progressBar = document.querySelector('.turbo-progress-bar');
        if (progressBar) { progressBar.remove(); }
      });
    </script>
  </head>

  <body>
    <header>
      <a href="/home">@drawohara</a> &mdash;
<a href="mailto:me-encanta-esto@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">me わ  esto!</a>
<small>
  <small>
    <small>
      <span title='bebe esto'>&lt;&lt; haz clic aqu铆   </a>
    </small>
  </small>
</small>
<hr>
<strong>/front-end-dependency-management-with-bower-ro-r</strong>
    </header>

    <main>
      <em>publicado el: 2013-07-12</em>
<br>
<br>
<div class="ro markdown">

<p>La gesti贸n de dependencias puede ser complicada. Cuando me un铆 a dojo4 hace unas semanas, fue genial clonar un repositorio de proyecto de ruby on rails, poder hacer un <code>bundle install</code> y luego poder ejecutar la aplicaci贸n con <code>rails s</code>. Para aquellos de ustedes que no est茅n familiarizados con la gesti贸n de dependencias de ruby on rails, las gemas que se necesitan para ejecutar la aplicaci贸n se enumeran en un archivo llamado <code>Gemfile</code>. La aplicaci贸n bundle lee este archivo gemfile y descarga e instala cualquier gema que a煤n no est茅 en su computadora. No solo esto hace que sea f谩cil poner en marcha la aplicaci贸n correctamente de manera r谩pida y sin mucho esfuerzo de configuraci贸n, sino que tambi茅n facilita la actualizaci贸n de esas gemas dependientes cuando se lanza una nueva versi贸n. Ejecutar <code>bundle update</code> o actualizar el archivo gemfile y volver a ejecutar <code>bundle install</code> hace que este sea un proceso f谩cil que garantiza que todos los dem谩s usuarios de la aplicaci贸n tambi茅n usar谩n la nueva versi贸n (siempre que compartamos los cambios a trav茅s del control de origen). Esta es una excelente manera de trabajar para el lado del servidor, pero 驴qu茅 pasa con el lado del cliente?</p>

<p>A medida que las aplicaciones del cliente se vuelven m谩s complicadas, a menudo necesitamos la ayuda de bibliotecas y marcos en el cliente tambi茅n. En dojo4, actualmente descargamos los archivos que necesitamos y los dejamos manualmente en el control de origen y los confirmamos. Los archivos est谩n bajo control de origen, por lo que al menos todos obtendr谩n esos archivos y podremos revertir una actualizaci贸n de versi贸n, pero es un poco desordenado. Para actualizar los archivos de la biblioteca, tenemos que repetir el proceso manual. En el lado del servidor, tambi茅n es realmente agradable que las tareas de gesti贸n de dependencias est茅n menos estrechamente acopladas al c贸digo de la aplicaci贸n para que actualizar y volver a versiones anteriores sea m谩s f谩cil. Desafortunadamente, no hab铆a una buena manera de gestionar las dependencias para el front end. Hasta hace poco.</p>

<p>En septiembre del a帽o pasado, Twitter lanz贸 <a href="http://bower.io">Bower</a>, que ofrece "una soluci贸n gen茅rica y sin opiniones al problema de la gesti贸n de paquetes del front-end". Bower proporciona las mismas capacidades para la aplicaci贸n del front-end que bundle hace para el back end: una lista central de dependencias en un archivo, comandos de instalaci贸n y actualizaci贸n f谩ciles, y algo de separaci贸n del c贸digo de la aplicaci贸n y los commits. Mientras investigaba c贸mo podr铆amos aprovechar esto en nuestra aplicaci贸n est谩ndar de ruby on rails, los creadores de Bower me remitieron a la <a href="https://github.com/42dev/bower-rails/">gema bower-rails</a>, que integra bower en la estructura de directorios de ruby on rails y agrega algunos comandos <code>rake</code> para ejecutar comandos de bower. Ahora, en lugar de confirmar manualmente los archivos de la biblioteca en el repositorio de la aplicaci贸n, un desarrollador puede hacer <code>rake bower:install [nombre del paquete]</code> y la 煤ltima versi贸n de ese paquete se instalar谩 en el pipeline de activos y se agregar谩 a la lista de paquetes requeridos. Un nuevo desarrollador puede luego descargar el c贸digo de la aplicaci贸n y, despu茅s de ejecutar <code>bundle install</code>, puede ejecutar <code>rake bower:install</code> y todas las dependencias del front-end se instalar谩n en el directorio adecuado en el pipeline de activos de ruby on rails para su uso inmediato.</p>

<p>Personalmente, me gusta mucho este enfoque y espero que podamos convertir las bibliotecas del front-end que se agregan manualmente al enfoque de bower. Todav铆a estamos discutiendo internamente los beneficios y desventajas y tomaremos una decisi贸n pronto. 驴Qu茅 piensas? 驴C贸mo manejas las dependencias del front-end en un equipo distribuido?</p>

</div>
    </main>

    <footer>
      <hr>
<a href="/goto" name="goto">&mdash;&gt; ir</a>
<blockquote>
<ul>
  <li>
    <a href="mailto:odio-esto@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">,  ^esto!<a>
  </li>
  <li>
    <a href="/now">/ahora<a>
  </li>
  <li>
    <a href="/about">/sobre<a>
  </li>
  <li>
    <a href="/contact">/contacto<a>
  </li>
</ul>
</blockquote>
<a href="/">&lt;&mdash; salir</a>
    </footer>
  </body>
</html>