<html color-mode="user" lang="it">
  <head>
  <!-- ga -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQVD9T27V4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQVD9T27V4');
</script>

  <!-- deps -->
    <script type="module" src="/assets/js/turbo.es2017-esm.js" defer></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.fluid.classless.fuchsia.min.css"
    >

  <!-- langs -->
  <!--
    https://developers.google.com/search/docs/specialty/international/localized-versions#html
  -->
   <link rel="alternate" hreflang="en" href="/" />
   <link rel="alternate" hreflang="uk" href="https://drawohara.io/langs/uk" />
   <link rel="alternate" hreflang="sv" href="https://drawohara.io/langs/sv" />
   <link rel="alternate" hreflang="fr" href="https://drawohara.io/langs/fr" />
   <link rel="alternate" hreflang="es" href="https://drawohara.io/langs/es" />
   <link rel="alternate" hreflang="it" href="https://drawohara.io/langs/it" />

  <!-- defaults -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark" />

  <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

  <!-- meta -->
    <title>non c'√® niente da vedere qui.</title>

<meta property="og:title" content="non c'√® niente da vedere qui."/>
<meta property="og:description" content="circolare." />
<meta property="og:image" content="https://drawohara.io/media/mick.jpg" />

<meta property="og:image:type" content="image/jpeg" />

    <meta property="site:route" content=""/dojo4/archive/:id"">
    <meta property="site:params" content="{"ext":null,"id":"front-end-dependency-management-with-bower-ro-r"}">
    <meta property="site:path_info" content=""/front-end-dependency-management-with-bower-ro-r"">

    <base href='/langs/it' />

    <style>
      /* anti pico */
      a {text-decoration: none !important; }

      /* anti turbo */
      html { transition: none !important; }
      .turbo-progress-bar { visibility: hidden; }

      /* anti progressive */
      html { margin: 1em; }
      img { display: block; text-align: center; }
    </style>

    <script>
      document.addEventListener("turbo:load", function() {
        const progressBar = document.querySelector('.turbo-progress-bar');
        if (progressBar) { progressBar.remove(); }
      });
    </script>
  </head>

  <body>
    <header>
      <a href="/home">@drawohara</a> &mdash;
<a href="mailto:i-love-this@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">io ‚ù§Ô∏è questo!</a>
<small>
  <small>
    <small>
      <span title='bevimi'>&lt;&lt; clicca qui üêõ ü´ñ üßö</a>
    </small>
  </small>
</small>
<hr>
<strong>/front-end-dependency-management-with-bower-ro-r</strong>
    </header>

    <main>
      <em>pubblicato il: 2013-07-12</em>
<br>
<br>
<div class="ro markdown">

<p>La gestione delle dipendenze pu√≤ essere complicata. Quando sono entrato a far parte di dojo4 alcune settimane fa, √® stato fantastico clonare un repository di un progetto ruby on rails, essere in grado di eseguire un <code>bundle install</code> e quindi eseguire l'app con <code>rails s</code>. Per coloro che non sono familiari con la gestione delle dipendenze di ruby on rails, le gemme necessarie per eseguire l'applicazione sono elencate in un file chiamato <code>Gemfile</code>. L'applicazione bundle legge questo gemfile e scarica e installa eventuali gemme che non sono ancora sul tuo computer. Non solo questo rende facile far funzionare l'applicazione correttamente in modo rapido e senza troppo sforzo di configurazione, ma rende anche facile aggiornare quelle gemme dipendenti quando viene rilasciata una nuova versione. Eseguire <code>bundle update</code> o aggiornare il gemfile ed eseguire nuovamente <code>bundle install</code> rende questo un processo semplice che garantisce che ogni altro utente dell'app utilizzer√† anche la nuova versione (purch√© condividiamo le modifiche tramite il controllo della sorgente). Questo √® un ottimo flusso di lavoro per il lato server, ma cosa succede per il lato client?</p>

<p>Man mano che le applicazioni client diventano pi√π complesse, spesso abbiamo bisogno dell'assistenza di librerie e framework anche sul client. Attualmente, in dojo4, scarichiamo i file di cui abbiamo bisogno e li inseriamo manualmente nel controllo della sorgente e li committiamo. I file sono sotto controllo della sorgente, quindi almeno tutti otterranno quei file e possiamo ripristinare un aggiornamento della versione, ma √® un po' disordinato. Per aggiornare i file della libreria dobbiamo ripetere il processo manuale. Anche sul lato server, √® molto comodo che i compiti di gestione delle dipendenze siano meno strettamente accoppiati al codice dell'applicazione in modo che l'aggiornamento e il ripristino delle versioni siano pi√π semplici. Purtroppo, non c'era un modo efficace per gestire le dipendenze per il front end. Fino a poco tempo fa.</p>

<p>A settembre dello scorso anno, Twitter ha rilasciato <a href="http://bower.io">Bower</a>, che offre "una soluzione generica e non opinabile al problema della gestione dei pacchetti front-end". Bower fornisce le stesse capacit√† per l'applicazione front-end che bundle fornisce per il back-end: un elenco centrale delle dipendenze in un file, comandi di installazione e aggiornamento facili e una certa separazione dai commit del codice dell'app. Mentre studiavo come potevamo sfruttare questo nella nostra applicazione ruby on rails standard, i creatori di Bower mi hanno indirizzato alla <a href="https://github.com/42dev/bower-rails/">gemma bower-rails</a>, che integra bower nella struttura delle directory di ruby on rails e aggiunge alcuni comandi <code>rake</code> per eseguire i comandi bower. Ora, invece di committare manualmente i file della libreria nel repository dell'app, uno sviluppatore pu√≤ eseguire <code>rake bower:install [nome del pacchetto]</code> e l'ultima versione di quel pacchetto verr√† installata nella pipeline degli asset e verr√† aggiunta all'elenco dei pacchetti richiesti. Un nuovo sviluppatore pu√≤ quindi scaricare il codice dell'app e, dopo aver eseguito <code>bundle install</code>, pu√≤ eseguire <code>rake bower:install</code> e tutte le dipendenze front-end verranno installate nella directory corretta nella pipeline degli asset di ruby on rails per l'uso immediato.</p>

<p>Personalmente, mi piace molto questo approccio e spero che possiamo convertire le librerie front-end aggiunte manualmente all'approccio bower. Stiamo ancora discutendo internamente i vantaggi e gli svantaggi e prenderemo presto una decisione. Cosa ne pensi? Come gestisci le dipendenze front-end in un team distribuito?</p>

</div>
    </main>

    <footer>
      <hr>
<a href="/goto" name="goto">&mdash;&gt; vai a</a>
<blockquote>
<ul>
  <li>
    <a href="mailto:i-hate-this@drawohara.io?subject=/front-end-dependency-management-with-bower-ro-r">üò©, io üñ§ ^questo!<a>
  </li>
  <li>
    <a href="/now">/ora<a>
  </li>
  <li>
    <a href="/about">/chi-siamo<a>
  </li>
  <li>
    <a href="/contact">/contatti<a>
  </li>
</ul>
</blockquote>
<a href="/">&lt;&mdash; eject</a>
    </footer>
  </body>
</html>